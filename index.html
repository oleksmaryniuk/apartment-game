<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Apartment Exploration</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background: #222;
    }
    #gameContainer {
      position: relative;
    }
    canvas {
      display: block;
      border: 2px solid #444;
    }
    #hud {
      position: absolute;
      top: 20px;
      right: 20px;
      display: flex;
      gap: 20px;
      font-size: 32px;
    }
    .hud-item {
      opacity: 0.3;
      filter: grayscale(100%);
      transition: all 0.3s ease;
    }
    .hud-item.collected {
      opacity: 1;
      filter: grayscale(0%);
      text-shadow: 0 0 10px #fff, 0 0 20px #ff0, 0 0 30px #ff0;
    }
    #message, #gameOverMessage {
      position: absolute;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 150, 150, 0.9);
      color: white;
      padding: 20px 40px;
      border-radius: 12px;
      font-family: Arial, sans-serif;
      font-size: 22px;
      text-align: center;
      display: none;
      box-shadow: 0 0 20px rgba(0, 200, 200, 0.5);
    }
    #gameOverMessage {
      background: rgba(150, 50, 50, 0.9);
      box-shadow: 0 0 20px rgba(200, 50, 50, 0.5);
    }
    #gameOverMessage button {
      margin-top: 15px;
      padding: 10px 30px;
      font-size: 18px;
      cursor: pointer;
      border: none;
      border-radius: 8px;
      background: #fff;
      color: #333;
    }
    #gameOverMessage button:hover {
      background: #ddd;
    }
    #mobileWarning {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #222;
      color: white;
      font-family: Arial, sans-serif;
      justify-content: center;
      align-items: center;
      text-align: center;
      padding: 40px;
      z-index: 9999;
    }
    #mobileWarning .content {
      max-width: 400px;
    }
    #mobileWarning h2 {
      font-size: 24px;
      margin-bottom: 20px;
    }
    #mobileWarning p {
      font-size: 16px;
      line-height: 1.6;
      color: #aaa;
    }
    #mobileWarning .emoji {
      font-size: 64px;
      margin-bottom: 20px;
    }
  </style>
</head>
<body>
  <div id="mobileWarning">
    <div class="content">
      <div class="emoji">üíª</div>
      <h2>–¶—è –≥—Ä–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ –ª–∏—à–µ –Ω–∞ –∫–æ–º–ø'—é—Ç–µ—Ä—ñ</h2>
      <p>–ë—É–¥—å –ª–∞—Å–∫–∞, –≤—ñ–¥–∫—Ä–∏–π —Ü—é —Å—Ç–æ—Ä—ñ–Ω–∫—É –Ω–∞ –∫–æ–º–ø'—é—Ç–µ—Ä—ñ –∞–±–æ –Ω–æ—É—Ç–±—É—Ü—ñ –¥–ª—è –Ω–∞–π–∫—Ä–∞—â–æ–≥–æ –¥–æ—Å–≤—ñ–¥—É.</p>
    </div>
  </div>
  <div id="gameContainer">
    <canvas id="gameCanvas" width="1200" height="800"></canvas>
    <div id="hud">
      <span id="keyIndicator" class="hud-item">üîë</span>
      <span id="eyesIndicator" class="hud-item">üëÄ</span>
    </div>
    <div id="message">–ú–æ–ª–æ–¥–µ—Ü—å, —Ç–∏ –∑–Ω–∞–π—à–ª–∞ "–≥–∞—Ä—è—á–µ", –¥–∞–ª—ñ —É–∂–µ —Å–ø—Ä–∞–≤–∞ –∑–∞ —Ç–æ–±–æ—é.</div>
    <div id="gameOverMessage">
      <div>–û–π! –¢–∏ –Ω–∞—Å—Ç—É–ø–∏–ª–∞ –Ω–∞ —â–æ—Å—å –Ω–µ–ø—Ä–∏—î–º–Ω–µ üò±</div>
      <button onclick="resetGame()">–°–ø—Ä–æ–±—É–≤–∞—Ç–∏ —â–µ —Ä–∞–∑</button>
    </div>
  </div>

  <script>
    // Mobile device detection
    function isMobile() {
      const userAgent = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      const smallScreen = window.innerWidth < 1024;
      return userAgent || smallScreen;
    }

    if (isMobile()) {
      document.getElementById('mobileWarning').style.display = 'flex';
      document.getElementById('gameContainer').style.display = 'none';
    }

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const keyIndicator = document.getElementById('keyIndicator');
    const eyesIndicator = document.getElementById('eyesIndicator');
    const messageEl = document.getElementById('message');
    const gameOverEl = document.getElementById('gameOverMessage');

    // Game constants
    const PLAYER_RADIUS = 16;
    const PLAYER_SPEED = 150; // pixels per second
    const PICKUP_DISTANCE = 50;
    const SPAWN_X = 573;
    const SPAWN_Y = 640;

    // Item positions (invisible on map)
    const KEY_POS = { x: 1030, y: 160 };
    const EYES_POS = { x: 615, y: 150 };

    // Obstacles (spiders and bananas)
    const OBSTACLE_RADIUS = 30;
    const OBSTACLE_MOVE_RADIUS = 45;
    const OBSTACLE_SPEED = 80; // pixels per second
    const obstacles = [
      // Spiders üï∑Ô∏è
      { baseX: 300, baseY: 600, x: 300, y: 600, targetX: 300, targetY: 600, type: 'spider' },
      { baseX: 850, baseY: 400, x: 850, y: 400, targetX: 850, targetY: 400, type: 'spider' },
      { baseX: 950, baseY: 650, x: 950, y: 650, targetX: 950, targetY: 650, type: 'spider' },
      { baseX: 450, baseY: 450, x: 450, y: 450, targetX: 450, targetY: 450, type: 'spider' },
      { baseX: 500, baseY: 180, x: 500, y: 180, targetX: 500, targetY: 180, type: 'spider' }, // Top room
      // Bananas üçå
      { baseX: 200, baseY: 500, x: 200, y: 500, targetX: 200, targetY: 500, type: 'banana' },
      { baseX: 650, baseY: 650, x: 650, y: 650, targetX: 650, targetY: 650, type: 'banana' },
      { baseX: 900, baseY: 200, x: 900, y: 200, targetX: 900, targetY: 200, type: 'banana' },
      { baseX: 550, baseY: 380, x: 550, y: 380, targetX: 550, targetY: 380, type: 'banana' },
      { baseX: 650, baseY: 200, x: 650, y: 200, targetX: 650, targetY: 200, type: 'banana' }, // Top room
      // Rats üêÄ
      { baseX: 180, baseY: 650, x: 180, y: 650, targetX: 180, targetY: 650, type: 'rat' },
      { baseX: 800, baseY: 550, x: 800, y: 550, targetX: 800, targetY: 550, type: 'rat' },
      { baseX: 320, baseY: 150, x: 320, y: 150, targetX: 320, targetY: 150, type: 'rat' }, // Top room
    ];

    // Generate random target within movement radius
    function setNewTarget(obs) {
      const angle = Math.random() * Math.PI * 2;
      const dist = Math.random() * OBSTACLE_MOVE_RADIUS;
      obs.targetX = obs.baseX + Math.cos(angle) * dist;
      obs.targetY = obs.baseY + Math.sin(angle) * dist;
    }

    // Initialize random targets
    obstacles.forEach(obs => setNewTarget(obs));

    // Static walls
    const staticWalls = [
      // Outer perimeter walls
      { x: 100, y: 75, width: 1000, height: 8 },     // Top wall
      { x: 1092, y: 75, width: 8, height: 650 },     // Right wall
      { x: 100, y: 717, width: 1000, height: 8 },    // Bottom wall
      { x: 100, y: 75, width: 8, height: 500 },      // Left wall (upper part)
      { x: 100, y: 525, width: 8, height: 200 },     // Left wall (lower part)

      // Left room walls
      //{ x: 100, y: 442, width: 280, height: 8 },     // Bottom wall of left room
      { x: 372, y: 300, width: 8, height: 150 },     // Right wall of left room

      // Center room walls
      { x: 722, y: 75, width: 8, height: 225 },     // Top horizontal wall of center room
      { x: 380, y: 292, width: 390, height: 8 },     // Top wall of center room
      { x: 762, y: 300, width: 8, height: 250 },     // Right wall of center room
      { x: 510, y: 542, width: 260, height: 8 },     // Bottom wall of center room
    ];

    // Conditional wall (blocks kitchen entrance until key is collected)
    const conditionalWall = { x: 100, y: 442, width: 280, height: 8 };

    // Glow position (center of conditional wall, 120px higher)
    const GLOW_X = conditionalWall.x + conditionalWall.width / 2;
    const GLOW_Y = conditionalWall.y - 120;
    const GLOW_RADIUS = 60;

    // Game state
    let player = { x: SPAWN_X, y: SPAWN_Y };
    let hasKey = false;
    let hasEyes = false;
    let gameOver = false;
    let keys = { up: false, down: false, left: false, right: false };
    let lastTime = 0;

    // Get active walls based on game state
    function getActiveWalls() {
      if (hasKey) {
        return staticWalls;
      }
      return [...staticWalls, conditionalWall];
    }

    // Circle vs AABB collision detection
    function circleRectCollision(cx, cy, radius, rect) {
      const closestX = Math.max(rect.x, Math.min(cx, rect.x + rect.width));
      const closestY = Math.max(rect.y, Math.min(cy, rect.y + rect.height));
      const dx = cx - closestX;
      const dy = cy - closestY;
      return (dx * dx + dy * dy) < (radius * radius);
    }

    // Check if position collides with any wall
    function collidesWithWalls(x, y) {
      const walls = getActiveWalls();
      for (const wall of walls) {
        if (circleRectCollision(x, y, PLAYER_RADIUS, wall)) {
          return true;
        }
      }
      return false;
    }

    // Keep player in bounds
    function clampToBounds(x, y) {
      const minX = PLAYER_RADIUS;
      const maxX = canvas.width - PLAYER_RADIUS;
      const minY = PLAYER_RADIUS;
      const maxY = canvas.height - PLAYER_RADIUS;
      return {
        x: Math.max(minX, Math.min(maxX, x)),
        y: Math.max(minY, Math.min(maxY, y))
      };
    }

    // Calculate distance between two points
    function distance(x1, y1, x2, y2) {
      const dx = x2 - x1;
      const dy = y2 - y1;
      return Math.sqrt(dx * dx + dy * dy);
    }

    // Check obstacle collision
    function checkObstacleCollision() {
      for (const obs of obstacles) {
        if (distance(player.x, player.y, obs.x, obs.y) < PLAYER_RADIUS + OBSTACLE_RADIUS - 10) {
          return true;
        }
      }
      return false;
    }

    // Update obstacle positions (only spiders move)
    function updateObstacles(deltaTime) {
      for (const obs of obstacles) {
        if (obs.type === 'banana') continue; // Bananas don't move

        const dx = obs.targetX - obs.x;
        const dy = obs.targetY - obs.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < 2) {
          // Reached target, set new one
          setNewTarget(obs);
        } else {
          // Move towards target
          const moveAmount = OBSTACLE_SPEED * deltaTime;
          const ratio = Math.min(moveAmount / dist, 1);
          obs.x += dx * ratio;
          obs.y += dy * ratio;
        }
      }
    }

    // Update game state
    function update(deltaTime) {
      // Always update obstacles for animation
      updateObstacles(deltaTime);

      if (hasEyes || gameOver) return; // Game won or lost, stop updating

      // Calculate movement direction
      let dx = 0;
      let dy = 0;
      if (keys.up) dy -= 1;
      if (keys.down) dy += 1;
      if (keys.left) dx -= 1;
      if (keys.right) dx += 1;

      // Normalize diagonal movement
      if (dx !== 0 && dy !== 0) {
        const len = Math.sqrt(dx * dx + dy * dy);
        dx /= len;
        dy /= len;
      }

      // Calculate new position
      const moveAmount = PLAYER_SPEED * deltaTime;
      let newX = player.x + dx * moveAmount;
      let newY = player.y + dy * moveAmount;

      // Clamp to bounds
      const bounded = clampToBounds(newX, newY);
      newX = bounded.x;
      newY = bounded.y;

      // Axis-separated collision for smooth sliding
      // Try X movement first
      if (!collidesWithWalls(newX, player.y)) {
        player.x = newX;
      }
      // Try Y movement
      if (!collidesWithWalls(player.x, newY)) {
        player.y = newY;
      }

      // Check item pickups
      if (!hasKey && distance(player.x, player.y, KEY_POS.x, KEY_POS.y) < PICKUP_DISTANCE) {
        hasKey = true;
        keyIndicator.classList.add('collected');
      }

      if (hasKey && !hasEyes && distance(player.x, player.y, EYES_POS.x, EYES_POS.y) < PICKUP_DISTANCE) {
        hasEyes = true;
        eyesIndicator.classList.add('collected');
        messageEl.style.display = 'block';
      }

      // Check obstacle collision
      if (checkObstacleCollision()) {
        gameOver = true;
        gameOverEl.style.display = 'block';
      }
    }

    // Reset game
    function resetGame() {
      player.x = SPAWN_X;
      player.y = SPAWN_Y;
      hasKey = false;
      hasEyes = false;
      gameOver = false;
      keyIndicator.classList.remove('collected');
      eyesIndicator.classList.remove('collected');
      messageEl.style.display = 'none';
      gameOverEl.style.display = 'none';
      // Reset obstacle positions
      obstacles.forEach(obs => {
        obs.x = obs.baseX;
        obs.y = obs.baseY;
        setNewTarget(obs);
      });
    }

    // Render game
    function render() {
      // Clear canvas with white background
      ctx.fillStyle = '#fff';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw walls
      ctx.fillStyle = '#000';
      const walls = getActiveWalls();
      for (const wall of walls) {
        ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
      }

      // Draw obstacles (1.5x bigger)
      ctx.font = '42px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      for (const obs of obstacles) {
        if (obs.type === 'spider') {
          ctx.fillText('üï∑Ô∏è', obs.x, obs.y);
        } else if (obs.type === 'banana') {
          ctx.fillText('üçå', obs.x, obs.y);
        } else if (obs.type === 'rat') {
          ctx.fillText('üêÄ', obs.x, obs.y);
        }
      }

      // Draw sun glow when eyes collected (highlights where wall disappeared)
      if (hasEyes) {
        const gradient = ctx.createRadialGradient(GLOW_X, GLOW_Y, 0, GLOW_X, GLOW_Y, GLOW_RADIUS);
        gradient.addColorStop(0, 'rgba(150, 255, 255, 0.9)');
        gradient.addColorStop(0.3, 'rgba(100, 220, 220, 0.6)');
        gradient.addColorStop(0.7, 'rgba(50, 180, 180, 0.3)');
        gradient.addColorStop(1, 'rgba(0, 150, 150, 0)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(GLOW_X, GLOW_Y, GLOW_RADIUS, 0, Math.PI * 2);
        ctx.fill();
      }

      // Draw princess
      const px = player.x;
      const py = player.y;

      // Dress (muted green, triangular shape)
      ctx.fillStyle = '#6B8E6B';
      ctx.beginPath();
      ctx.moveTo(px - 12, py + 16);
      ctx.lineTo(px + 12, py + 16);
      ctx.lineTo(px + 6, py - 2);
      ctx.lineTo(px - 6, py - 2);
      ctx.closePath();
      ctx.fill();

      // Dress details (darker green line)
      ctx.strokeStyle = '#4A6B4A';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(px, py - 2);
      ctx.lineTo(px, py + 14);
      ctx.stroke();

      // Body/torso (skin color)
      ctx.fillStyle = '#FFDBAC';
      ctx.fillRect(px - 4, py - 6, 8, 6);

      // Arms
      ctx.fillStyle = '#FFDBAC';
      ctx.fillRect(px - 8, py - 5, 4, 8);
      ctx.fillRect(px + 4, py - 5, 4, 8);

      // Head (skin)
      ctx.fillStyle = '#FFDBAC';
      ctx.beginPath();
      ctx.arc(px, py - 12, 7, 0, Math.PI * 2);
      ctx.fill();

      // Hair (blonde)
      ctx.fillStyle = '#F4D03F';
      ctx.beginPath();
      ctx.arc(px, py - 14, 7, Math.PI, Math.PI * 2);
      ctx.fill();
      // Hair sides
      ctx.fillRect(px - 7, py - 14, 3, 10);
      ctx.fillRect(px + 4, py - 14, 3, 10);

      // Crown/tiara
      ctx.fillStyle = '#FFD700';
      ctx.beginPath();
      ctx.moveTo(px - 5, py - 19);
      ctx.lineTo(px - 3, py - 23);
      ctx.lineTo(px, py - 20);
      ctx.lineTo(px + 3, py - 23);
      ctx.lineTo(px + 5, py - 19);
      ctx.closePath();
      ctx.fill();

      // Crown gem
      ctx.fillStyle = '#FF1493';
      ctx.beginPath();
      ctx.arc(px, py - 21, 2, 0, Math.PI * 2);
      ctx.fill();

      // Eyes (blue)
      ctx.fillStyle = '#1E90FF';
      ctx.beginPath();
      ctx.arc(px - 3, py - 12, 1.5, 0, Math.PI * 2);
      ctx.arc(px + 3, py - 12, 1.5, 0, Math.PI * 2);
      ctx.fill();

      // Smile
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(px, py - 10, 3, 0.1 * Math.PI, 0.9 * Math.PI);
      ctx.stroke();
    }

    // Game loop
    function gameLoop(currentTime) {
      const deltaTime = (currentTime - lastTime) / 1000;
      lastTime = currentTime;

      update(deltaTime);
      render();

      requestAnimationFrame(gameLoop);
    }

    // Input handling
    document.addEventListener('keydown', (e) => {
      switch (e.key) {
        case 'ArrowUp': keys.up = true; e.preventDefault(); break;
        case 'ArrowDown': keys.down = true; e.preventDefault(); break;
        case 'ArrowLeft': keys.left = true; e.preventDefault(); break;
        case 'ArrowRight': keys.right = true; e.preventDefault(); break;
        case 'Enter':
          if (gameOver) {
            resetGame();
            e.preventDefault();
          }
          break;
      }
    });

    document.addEventListener('keyup', (e) => {
      switch (e.key) {
        case 'ArrowUp': keys.up = false; break;
        case 'ArrowDown': keys.down = false; break;
        case 'ArrowLeft': keys.left = false; break;
        case 'ArrowRight': keys.right = false; break;
      }
    });

    // Start game
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
